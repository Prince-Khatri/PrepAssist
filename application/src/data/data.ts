export let DBdata = [
    {
        "text": "Unit 2: Process Synchronization & Deadlocks  \n \n1. Producer -Consumer Problem  \n• Definition : \no A synchronization problem where the producer generates data and places it in a shared \nbuffer, and the consumer retrieves it.  \n• Challenges : \no Prevent producer from overwriting a full buffer.  \no Prevent consumer from accessing an empty buffer.  \no Avoid race conditions when both try to access the shared buffer at the same time.  \n• Solution : \no Use semaphores  to synchronize producer and consumer actions:  \n1. Empty Semaphore : Tracks available slots in the buffer.  \n2. Full Semaphore : Tracks filled slots in the buffer.  \n3. Mutex Semaphore : Ensures mutual exclusion during buffer access.  \no Implementation : \n▪ The producer waits on empty and acquires the mutex before producing.  \n▪ The consumer waits on full and acquires the mutex before consuming.  \n▪ The mutex ensures only one process (producer or consumer) accesses the buffer \nat a time.  \n \n2. Process Synchronization  \n• Purpose : \no Ensures processes sharing resources don’t interfere with each other.  \no Avoids issues like race conditions and data inconsistencies.  \n• Mechanisms : \no Semaphores : Used to signal between processes.  \no Locks : Ensure exclusive access to critical resources.  \n 3. Race Condition  \n• Definition : \no Occurs when multiple processes access shared data simultaneously, leading to \nunpredictable results.  \n• Example in Producer -Consumer Problem : \no Producer and consumer may simultaneously try to modify the buffer, resulting in data \ncorruption or invalid operations.  \n• Solution in Producer -Consumer : \no Use synchronization mechanisms (semaphores or locks) to ensure only one process \naccesses the buffer at a time:  \n▪ Empty Semaphore  prevents the producer from adding to a full buffer.  \n▪ Full Semaphore  prevents the consumer from removing from an empty buffer.  \n▪ Mutex  ensures mutual exclusion during updates to the buffer.  \n \n4. Critical Section Problem  \n• A segment of code accessing shared resources.  \n• Requirements for Solutions : \no Mutual Exclusion : One process at a time in the critical section.  \no Progress : Waiting processes should eventually enter the critical section.  \no Bounded Waiting : No indefinite delays.  \n \n5. Peterson’s Solution  \n• Software -based solution for mutual exclusion between two processes.  \n• Steps : \no Use flag to indicate process interest and turn to decide whose turn it is.  \no Guarantees mutual exclusion, progress, and bounded waiting.  \n \n6. Deadlocks  \n• Definition : \no Processes get stuck waiting for resources held by each other.  • Necessary Conditions : \n1. Mutual Exclusion : Resources cannot be shared.  \n2. Hold and Wait : Processes hold resources while requesting more.  \n3. No Preemption : Resources cannot be forcibly taken.  \n4. Circular Wait : Processes form a cycle of resource dependencies.  \n \n7. Deadlock Prevention  \n• Removes at least one of the necessary conditions for a deadlock.  \n• Techniques : \no Avoid Hold and Wait : Request all resources at once.  \no Prevent Circular Wait : Use a strict ordering of resource allocation.  \n \n8. Deadlock Avoidance  \n• Dynamically checks system state to avoid unsafe conditions.  \n• Banker’s Algorithm : \no Simulates allocation and ensures the system remains in a safe state.  \n \n9. Safe and Unsafe States  \n• Safe State : All processes can complete without deadlocks.  \n• Unsafe State : Risk of deadlocks exists.  \n \n10. Example Problem  \n• Use a matrix to represent:  \no Allocation : Resources allocated to processes.  \no Maximum : Maximum resources a process needs.  \no Available : Free resources.  \n• Apply Banker’s Algorithm to verify safety before granting resource requests.  \n \n 11. Difference Between Deadlock Prevention and Avoidance : \n \nAspect  Prevention  Avoidance  \nApproach  Proactively eliminates \nconditions causing deadlocks.  Dynamically checks for safe \nstates.  \nComplexity  Simple to implement . Requires constant monitoring.  \nResource Utilization  May underutilize resources.  Efficiently uses available \nresources.  \n \n   \n   \n"
    },
    {
        "text": "Unit 2: Process Synchronization & Deadlocks  \n \n1. Producer -Consumer Problem  \n• Definition : \no A synchronization problem where the producer generates data and places it in a shared \nbuffer, and the consumer retrieves it.  \n• Challenges : \no Prevent producer from overwriting a full buffer.  \no Prevent consumer from accessing an empty buffer.  \no Avoid race conditions when both try to access the shared buffer at the same time.  \n• Solution : \no Use semaphores  to synchronize producer and consumer actions:  \n1. Empty Semaphore : Tracks available slots in the buffer.  \n2. Full Semaphore : Tracks filled slots in the buffer.  \n3. Mutex Semaphore : Ensures mutual exclusion during buffer access.  \no Implementation : \n▪ The producer waits on empty and acquires the mutex before producing.  \n▪ The consumer waits on full and acquires the mutex before consuming.  \n▪ The mutex ensures only one process (producer or consumer) accesses the buffer \nat a time.  \n \n2. Process Synchronization  \n• Purpose : \no Ensures processes sharing resources don’t interfere with each other.  \no Avoids issues like race conditions and data inconsistencies.  \n• Mechanisms : \no Semaphores : Used to signal between processes.  \no Locks : Ensure exclusive access to critical resources.  \n 3. Race Condition  \n• Definition : \no Occurs when multiple processes access shared data simultaneously, leading to \nunpredictable results.  \n• Example in Producer -Consumer Problem : \no Producer and consumer may simultaneously try to modify the buffer, resulting in data \ncorruption or invalid operations.  \n• Solution in Producer -Consumer : \no Use synchronization mechanisms (semaphores or locks) to ensure only one process \naccesses the buffer at a time:  \n▪ Empty Semaphore  prevents the producer from adding to a full buffer.  \n▪ Full Semaphore  prevents the consumer from removing from an empty buffer.  \n▪ Mutex  ensures mutual exclusion during updates to the buffer.  \n \n4. Critical Section Problem  \n• A segment of code accessing shared resources.  \n• Requirements for Solutions : \no Mutual Exclusion : One process at a time in the critical section.  \no Progress : Waiting processes should eventually enter the critical section.  \no Bounded Waiting : No indefinite delays.  \n \n5. Peterson’s Solution  \n• Software -based solution for mutual exclusion between two processes.  \n• Steps : \no Use flag to indicate process interest and turn to decide whose turn it is.  \no Guarantees mutual exclusion, progress, and bounded waiting.  \n \n6. Deadlocks  \n• Definition : \no Processes get stuck waiting for resources held by each other.  • Necessary Conditions : \n1. Mutual Exclusion : Resources cannot be shared.  \n2. Hold and Wait : Processes hold resources while requesting more.  \n3. No Preemption : Resources cannot be forcibly taken.  \n4. Circular Wait : Processes form a cycle of resource dependencies.  \n \n7. Deadlock Prevention  \n• Removes at least one of the necessary conditions for a deadlock.  \n• Techniques : \no Avoid Hold and Wait : Request all resources at once.  \no Prevent Circular Wait : Use a strict ordering of resource allocation.  \n \n8. Deadlock Avoidance  \n• Dynamically checks system state to avoid unsafe conditions.  \n• Banker’s Algorithm : \no Simulates allocation and ensures the system remains in a safe state.  \n \n9. Safe and Unsafe States  \n• Safe State : All processes can complete without deadlocks.  \n• Unsafe State : Risk of deadlocks exists.  \n \n10. Example Problem  \n• Use a matrix to represent:  \no Allocation : Resources allocated to processes.  \no Maximum : Maximum resources a process needs.  \no Available : Free resources.  \n• Apply Banker’s Algorithm to verify safety before granting resource requests.  \n \n 11. Difference Between Deadlock Prevention and Avoidance : \n \nAspect  Prevention  Avoidance  \nApproach  Proactively eliminates \nconditions causing deadlocks.  Dynamically checks for safe \nstates.  \nComplexity  Simple to implement . Requires constant monitoring.  \nResource Utilization  May underutilize resources.  Efficiently uses available \nresources.  \n \n   \n   \n"
    },
];